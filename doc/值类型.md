# 值类型

在 JavaScript 中，变量没有类型，变量中的值有类型。引擎针对不同类型实现了对应的常见操作的程序集（原型链上的方法）

**类型**
1. string
2. number
3. bigint
4. boolean
5. symbol
6. undefined
7. null
8. object

## string

JavaScript 使用 Unicode 字符集的 UTF-16 编码，因此字符串是**无符号 16 位值**的序列。每个 Unicode 字符的**码点**（codepoint）范围为 U+0000到U+10FFFF，字符串的每个「无符号 16 位值」为一个[UTF-16码元](https://zh.wikipedia.org/wiki/UTF-16)，因此一个 Unicode 码点需要 1 个或 2 个码元来表示。

UTF-16保留 0xD800-0xDFFF 区块的码位对辅助平面的字符的码位进行编码，采用**代理对**（surrogate pair）的形式存储一个码点，代理对是一对 16 位码元。**前导代理**其值在 0xD800-0xDBFF 之间，**后尾代理**其值在 0xDC00-0xDFFF 之间。前导代理与后尾代理单独出现时，不代表任何 Unicode 字符，称其为**单独代理项**。

### 字面量语法

```js
const s1 = 'str' // 单引号中可以包含双引号与反引号
const s2 = "str" // 双引号中可以包含单引号与反引号

// 模板字面量
const s3 = `str` // 反引号中可以包含单引号与双引号
const s4 = `s${s1}r` // 位于 ${ 和对应的 } 之间的内容作为**表达式**来解释
/*
 * 标签化模板字面量（tagged template literal）
 * 将模板字面量中的文本和表达式的值作为参数传给函数
 */
functionFn`a${b}c${d}` // functionFn(['a', 'c', ''], b, d)
```
#### 多行语法
JavaScript 最早版本要求字符串字面量必须写在一行。ES5 允许在每行末尾加一个反斜杠（\）从而将字符串字面量写在多行上，反斜杠与行终结符都不属于字符串字面量。ES6 支持反引号语法，允许跨行字符串，行终结符也是字符串的一部分。
```js
// s1.length => 4；想要在单引号或双引号中包含换行符需使用字符序列 \n
const s1 = 's\ntr'
// s2.length => 3；反斜杠与行终结符不属于字符串
const s2 = 's\
tr'
// s3.length => 4；行终结符属于字符串
const s3 = `s
tr`
```

#### 转义序列

在JavaScript中，转义序列（Escape Sequences）是一种特殊的字符序列，用于表示无法直接在字符串中使用的字符，或者具有特定意义的字符。通过使用转义序列，可以在字符串中插入特殊字符、控制字符、Unicode字符等。转义序列以反斜杠（\）开头，后跟一个或多个字符，以指定要表示的特殊字符。

**JavaScript 中定义的转义序列**

|序列|表示的字符|序列|表示的字符|
|---|---|---|---|
|`\0`|NUL字符（\u0000）|`\b`|退格字符（\u0008）|
|`\t`|水平制表符（\u0009）|`\n`|换行符（\u000A）|
|`\v`|垂直制表符（\u000B）|`\f`|进纸符（\u000C）|
|`\r`|回车符（\u000D）|`\"`|双引号（\u0022）|
|`\'`|单引号或撇号（\u0027）|`\\`|反斜杠（\u005C）|
|`\xnn`|由 2 位十六进制数字 nn 指定的 Unicode 字符|`\unnnn`|由 4 位十六进制数字 nnnn 指定的 Unicode 字符|
|`\u{n}`|由码点 n 指定的 Unicode字符，其中 n 是介于 0 和 10FFFF 之间的 1 到 6 位十六进制数字|

如果字符 \ 位于上表之外的字符前面，反斜杠会被忽略

### 运行时值可访问的成员

理论上只有 object 类型才有属性值，但在运行时，string 类型数据访问属性时，引擎内部会将其转换成包装对象，其原型指向 `String.prototype`，因此原型链上存储的值都可以被 string 类型值通过属性访问操作符访问到。

JavaScript 中字符串是不可变的，**不可变**指的是字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。

#### [String.prototype](./String.md#stringprototype)

#### Object.prototype


## number

JavaScript 中 number 类型的存储规则是遵循 IEEE754 64 位双精度浮点数。(安全整数范围)

### 数值字面量

[digits][.digits][(E|e)[(+|-)]digits]

```
let billion = 1000000000
let billion = 1_000_000_000
let billion = 1e9
// 十六进制
console.log(0xff)
console.log(0xFF)
// 八进制
console.log(0o77)
// 二进制
console.log(0b11)
```
### 特殊值

- `Infinity`
- `NaN`：Not a Number

## symbol

每个 symbol 值都是唯一的，主要目的是作为对象属性的标识符。

```
// 创建 symbol 值
const s = Symbol('sym') // 'sym' 仅为 symbol 值的描述

typeof s // symbol

// 每个 symbol 值都是唯一的
const s= Symbol('sym')
s === s1 // false

// 属性访问运算符 可将 symbol 类型值转换成对应的包装对象
s.description // 'sym'
s.toString() // 'Symbol(sym)'

// 显示创建包装对象
const sObj = Object(s)
new Symbol(s) // Uncaught TypeError: Symbol is not a constructor

// 包装对象拆封情况
Object(s) == s // true
const obj = { [sObj]: 'sObj' } // sObj => Object(s)
obj[sObj] // 'sObj', symbol 包装对象作为属性健时会被拆封为原始值
obj[s] // 'sObj'


// 类型转换
String(s) 'Symbol(sym)'
Number(s) // Uncaught TypeError: Cannot convert a Symbol value to a number
Object(s) // { description: 'sym', [[primitiveValue]]: Symbol(sym) }
Boolean(s) // true

// symbol 类型值不能与其他类型值做运算
+ // Uncaught TypeError: Cannot convert a Symbol value to a number
s + '' // Uncaught TypeError: Cannot convert a Symbol value to a string

// JSON.stringify() 会忽略 symbol 值作为健的属性
JSON.stringify({ [Symbol('symbolAttr')]: 'symbolAttr' }) // '{}'
```

## 参考

[IEEE 754 双精度浮点数](https://github.com/anjia/blog/issues/87)

[IEEE-754 64位双精度浮点数存储详解](https://blog.csdn.net/freeristantent/article/details/124066890)

[binary-system.base-conversion](https://binary-system.base-conversion.ro/convert-real-numbers-from-decimal-system-to-64bit-double-precision-IEEE754-binary-floating-point.php)

[binaryconvert](https://www.binaryconvert.com/result_double.html)
