# 值类型

在 JavaScript 中，变量没有类型，变量中的值有类型。引擎针对不同类型实现了对应的常见操作的程序集（原型链上的方法）

**类型**
1. string
2. number
3. bigint
4. boolean
5. symbol
6. undefined
7. null
8. object

## string

JavaScript 使用 Unicode 字符集的 UTF-16 编码，因此字符串是**无符号 16 位值**的序列。每个 Unicode 字符的**码点**（codepoint）范围为 U+0000到U+10FFFF，字符串的每个「无符号 16 位值」为一个[UTF-16码元](https://zh.wikipedia.org/wiki/UTF-16)，因此一个 Unicode 码点需要 1 个或 2 个码元来表示。

UTF-16保留 0xD800-0xDFFF 区块的码位对辅助平面的字符的码位进行编码，采用**代理对**（surrogate pair）的形式存储一个码点，代理对是一对 16 位码元。**前导代理**其值在 0xD800-0xDBFF 之间，**后尾代理**其值在 0xDC00-0xDFFF 之间。前导代理与后尾代理单独出现时，不代表任何 Unicode 字符，称其为**单独代理项**。

### 字面量语法

```js
const s1 = 'str' // 单引号
const s2 = "str" // 双引号
const s3 = `str` // 反引号
```

JavaScript 最早版本要求字符串字面量必须写在一行。ES5 允许在每行末尾加一个反斜杠（\）从而将字符串字面量写在多行上，反斜杠与行终结符都不属于字符串字面量。ES6 支持反引号语法，允许跨行字符串，行终结符也是字符串的一部分。
```js
// s1.length => 4；想要在单引号或双引号中包含换行符需使用字符序列 \n
const s1 = 's\ntr'
// s2.length => 3
const s2 = 's\
tr'
// s3.length => 4
const s3 = `s
tr`
```

#### 转义序列



### 运行时可访问属性值

理论上只有 object 类型才有属性值，但在运行时，string 类型数据访问属性时，引擎内部会将其转换成包装对象，其原型指向 `String.prototype`，因此原型链上存储的值都可以被 string 类型值通过属性访问操作符访问到。

#### 值作为属性
- length：UTF-16 码元的个数

#### 值作为方法
**访问字符串的个别字符**
- String.prototype.at：`at(index)`
    - 返回 index 处**码元字符**
    - 没有返回 `undefined`
    - index 为负数 => index + length
- String.prototype.charAt：`charAt(index)`
    - 返回 index 处**码元字符**
    - 没有返回 `''`
    = index => [0, len - 1]
- String.prototype.charCodeAt：`charCodeAt(index)`
    - 返回 index 处**码元值**
    - 没有返回 `NaN`
    - index => [0, len - 1]
- String.prototype.codePointAt：`codePonitAt(index)`[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)
    - 返回**码元index**处的**unicode码点**(index处为前导代理时)或**后尾代理码元**（index处为后尾代理时）
    - 没有返回 `undefined`
    - index => [0, len - 1]

**获取字符串的一部分**
- String.prototype.substring：``
- String.prototype.slice：``
- String.prototype.split：``

**搜索字符串**
- String.prototype.indexOf：``
- String.prototype.lastIndexOf：``

**ES6 及之后版本中的布尔值搜索函数
- String.prototype.endsWith：``
- String.prototype.includes：``
- String.prototype.startsWith：``

**创建字符串的修改版本**
- String.prototype.replace：``
- String.prototype.toUpperCase：``
- String.prototype.toLowserCase：``
- String.prototype.toLocaleUpperCase：``
- String.prototype.toLocaleLowerCase：``
- String.prototype.normalize：``


- String.prototype.match：``
- String.prototype.matchAll：``
- String.prototype.replaceAll：``
- String.prototype.search：``

- String.prototype.padStart：``
- String.prototype.padEnd：``

- String.prototype.isWellFormed：``
- String.prototype.toWellFormed：``

- String.prototype.trim：``
- String.prototype.trimStart：``
- String.prototype.trimEnd：``

- String.prototype.repeat：``
- String.prototype.concat：``
- String.prototype.localeCompare：``

- String.prototype[Symbol.iterator]：``
- String.prototype.toString：``
- String.prototype.valueOf：``

## number

JavaScript 中 number 类型的存储规则是遵循 IEEE754 64 位双精度浮点数。(安全整数范围)

### 数值字面量

[digits][.digits][(E|e)[(+|-)]digits]

```
let billion = 1000000000
let billion = 1_000_000_000
let billion = 1e9
// 十六进制
console.log(0xff)
console.log(0xFF)
// 八进制
console.log(0o77)
// 二进制
console.log(0b11)
```
### 特殊值

- `Infinity`
- `NaN`：Not a Number

## symbol

每个 symbol 值都是唯一的，主要目的是作为对象属性的标识符。

```
// 创建 symbol 值
const s = Symbol('sym') // 'sym' 仅为 symbol 值的描述

typeof s // symbol

// 每个 symbol 值都是唯一的
const s= Symbol('sym')
s === s1 // false

// 属性访问运算符 可将 symbol 类型值转换成对应的包装对象
s.description // 'sym'
s.toString() // 'Symbol(sym)'

// 显示创建包装对象
const sObj = Object(s)
new Symbol(s) // Uncaught TypeError: Symbol is not a constructor

// 包装对象拆封情况
Object(s) == s // true
const obj = { [sObj]: 'sObj' } // sObj => Object(s)
obj[sObj] // 'sObj', symbol 包装对象作为属性健时会被拆封为原始值
obj[s] // 'sObj'


// 类型转换
String(s) 'Symbol(sym)'
Number(s) // Uncaught TypeError: Cannot convert a Symbol value to a number
Object(s) // { description: 'sym', [[primitiveValue]]: Symbol(sym) }
Boolean(s) // true

// symbol 类型值不能与其他类型值做运算
+ // Uncaught TypeError: Cannot convert a Symbol value to a number
s + '' // Uncaught TypeError: Cannot convert a Symbol value to a string

// JSON.stringify() 会忽略 symbol 值作为健的属性
JSON.stringify({ [Symbol('symbolAttr')]: 'symbolAttr' }) // '{}'
```

## 参考

[IEEE 754 双精度浮点数](https://github.com/anjia/blog/issues/87)

[IEEE-754 64位双精度浮点数存储详解](https://blog.csdn.net/freeristantent/article/details/124066890)

[binary-system.base-conversion](https://binary-system.base-conversion.ro/convert-real-numbers-from-decimal-system-to-64bit-double-precision-IEEE754-binary-floating-point.php)

[binaryconvert](https://www.binaryconvert.com/result_double.html)
